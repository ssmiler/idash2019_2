\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}

% \sloppy

\usepackage{authblk}

\usepackage{graphicx}
\usepackage[]{subfigure}
\usepackage{algorithm} 
\usepackage{algpseudocode} 
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{xcolor}
% \usepackage{comment}
% \usepackage{nicefrac}
\usepackage{url}
\usepackage{eurosym}
% %\usepackage[normalem]{ulem}
% %\usepackage{showframe} %affiche le page frame pour debugguer
\usepackage{listings}
\usepackage[subtle]{savetrees}

\usepackage{tikz}

% %\usepackage{stmaryrd}
% \newcommand{\llbracket}{[\![}
% \newcommand{\rrbracket}{]\!]}

% \newcommand{\NICOLAS}[1]{{\color{blue}\textbf{NICOLAS:} {#1}}}
% \definecolor{mscolor}{rgb}{0,0.7,0.1}
% \newcommand{\ila}[1]{{\color{mscolor}\textbf{ILARIA:} {#1}}}
% \definecolor{macolor}{rgb}{0.7,0.7,0.1} 
% \newcommand{\MARIYA}[1]{{\color{magenta}\textbf{MARIYA:} {#1}}}
% \definecolor{micolor}{rgb}{0.8,0.2,0.1} 
% \newcommand{\TODO}[1]{{\color{micolor}{#1}}}
% \newcommand{\commentinvisible}[1]{}

% %\newfloat{algorithm}{tbp}{loa}
% %\providecommand{\algorithmname}{Algorithm}
% %\floatname{algorithm}{\protect\algorithmname}

% \usepackage{algorithm}
% \usepackage{algpseudocode}
% \algrenewcommand{\algorithmicrequire}{\textbf{Input:}}
% \algrenewcommand{\algorithmicensure}{\textbf{Output:}}


% %\newtheorem{definition}{Definition}[section]
% %\newtheorem{lemma}{Lemma}[section]
% %\newtheorem{theorem}{Theorem}[section]
% %\newtheorem{corollary}{Corollary}[section]
% \makeatletter
% \newcounter{globalcounter}[section]
% \renewcommand{\theglobalcounter}{\thesection.\arabic{globalcounter}}
% \spnewtheorem{globalenv}[globalcounter]{Dummy}{\bfseries}{\rmfamily}
% \spnewtheorem{assumption}[globalcounter]{Assumption}{\bfseries}{\rmfamily}
% \spnewtheorem{fact}[globalcounter]{Fact}{\bfseries}{\rmfamily}
% \let\c@definition\c@globalenv
% \let\thedefinition\theglobalcounter
% \let\c@lemma\c@globalenv
% \let\thelemma\theglobalcounter
% \let\c@corollary\c@globalenv
% \let\thecorollary\theglobalcounter
% \let\c@theorem\c@globalenv
% \let\thetheorem\theglobalcounter
% \makeatother

% \makeatletter
% %big cdot macro
% \newcommand*\bigcdot{\mathpalette\bigcdot@{.5}}
% \newcommand*\bigcdot@[2]{\mathbin{\vcenter{\hbox{\scalebox{#2}{$\m@th#1\bullet$}}}}}
% \makeatother


% \newcommand{\KeyGen}{\textsf{KeyGen}}
% \newcommand{\Encrypt}{\textsf{Enc}}
% \newcommand{\Decrypt}{\textsf{Dec}}
% \newcommand{\Eval}{\textsf{Eval}}
% \newcommand{\Refresh}{\textsf{Refresh}}
% \newcommand{\LWE}{\mathsf{LWE}}
% \newcommand{\GSW}{\sc{\mathrm{GSW}}}
% \newcommand{\SILWE}{\mathsf{SILWE}}
\newcommand{\RingLWE}{\sc{\mathrm{RingLWE}}}
% \newcommand{\TLWE}{\sc{\mathrm{TLWE}}}
% \newcommand{\TGSW}{\sc{\mathrm{TGSW}}}
% \newcommand{\LWEPubEncrypt}{\textsf{LWEPubEncrypt}}
% %\newcommand{\LWEDecrypt}{\textsf{LWEDecrypt}}
% \newcommand{\Message}{\textsf{msg}}
% \newcommand{\Error}{\textsf{Err}}
% \newcommand{\Variance}{\textsf{Var}}

% \newcommand{\RingGSW}{\sc{\mathrm{RingGSW}}}
% \newcommand{\SampleExtract}{\textsf{SampleExtract}}
% \newcommand{\KeyExtract}{\textsf{KeyExtract}}

% %gates
% \newcommand{\CMult}{\mathtt{CMult}}
% \newcommand{\Linear}{\mathtt{Linear}}
% \newcommand{\Cst}{\mathtt{Cst}}
% \newcommand{\CAnd}{\mathtt{CAnd}}
% \newcommand{\CMux}{\mathtt{CMux}}
% \newcommand{\Not}{\mathtt{Not}}

% \newcommand{\Bootstrap}{\textsf{Bootstrap}}
% \newcommand{\BK}{\textrm{BK}}
% \newcommand{\cR}{\mathcal{R}}
% \newcommand{\cS}{\mathcal{S}}
% \newcommand{\cM}{\mathcal{M}}
% \newcommand{\cMat}{\mathcal{M}}
% \newcommand{\cN}{\mathcal{N}}
% \newcommand{\bE}{\mathbb{E}}
% \newcommand{\cA}{\mathcal{A}}
% \newcommand{\cL}{\mathcal{L}}
% \newcommand{\cI}{\mathcal{I}}
% \newcommand{\cU}{\mathcal{U}}
% \newcommand{\cX}{\mathcal{X}}
% \newcommand{\cCU}{\mathcal{CU}}





\newcommand{\fT}{\mathfrak{T}}
\newcommand{\fR}{\mathfrak{R}}
\newcommand{\fA}{\mathcal{A}}
\newcommand{\mT}{\mathbb{T}}
\newcommand{\mN}{\mathbb{N}}
\newcommand{\mR}{\mathbb{R}}
\newcommand{\mZ}{\mathbb{Z}}
\newcommand{\mB}{\mathbb{B}}
\newcommand{\bbV}{\mathbb{V}}
\newcommand{\TnX}{\mT_N[X]}


\newcommand{\sergiu}[1]{{\color{red}{\textbf{SERGIU:} {#1}}}}
\newcommand{\nicolas}[1]{{\color{green}\textbf{NICOLAS:} {#1}}}
\newcommand{\mariya}[1]{{\color{pink}\textbf{MARIYA:} {#1}}}
\newcommand{\ila}[1]{{\color{blue}\textbf{ILA:} {#1}}}




\title{IDash 2019 submission}
\author[1]{Sergiu Carpov}
\author[2]{Ilaria Chillotti}
\author[3]{Nicolas Gama}
\author[3]{Mariya Georgieva}
\affil[1]{CEA LIST, Point Courrier 172, 91191 Gif-sur-Yvette Cedex, France}
\affil[2]{imec-COSIC, KU Leuven, Leuven, Belgium}
\affil[3]{Inpher, Lausanne, Switzerland}
\date{August 2019}





\begin{document}

\maketitle

\section{Plaintext version}

In this section we describe the plaintext idea of our solution.
The logreg model is trained in clear and the coefficients are given in cleartext to perform the homomorphic evaluation. 
To train the model we used the library Vowpal Wabbit (VW).

The parameters we use are:
\begin{itemize}
	\item $N$ -- the number of SNP values (one-hot-encoded);
	\item $L$ -- the number of samples (individuals);
	\item $T$ -- the numbers of tags SNP to predict.
\end{itemize}
In practice, $N$ is multiplied by 3: in fact the possible values for the SNP are 0, 1 and 2. 
In the experiments, $N = ?$, $L = 500$ and $T = 1500$.



The imput matrices are:
\begin{itemize}
	\item $X = (X[i][j])_{i\in [L], j\in [3\cdot N]}$ -- contains the input values, i.e. the SNP for each individual, as boolean values;
	\item $M = (M[j][k])_{j\in [3\cdot N], k\in [T]}$ -- contains the coefficients of the model in clear.
\end{itemize}
The evaluation consists in a matrix-matrix multiplication: 
$$
X \cdot M = Y = (Y[i][k])_{i\in [L], k\in [T]}.
$$ 







\section{Ciphertext version}

In ciphertext mode, we try to pack together as many coefficients as possible. 
The capability of the $\RingLWE$ packing is given by the ring dimension $n = 1024$.
We refer to TFHE~\cite{CGGI18} for more information.

Algorithm~\ref{alg:computation} describes our ciphertext approach. 
It has to be repeated for the 3 values of the SNP separately.



\begin{algorithm}
\caption{Homomorphic computation.}
\begin{algorithmic}[1]
    \Require $\RingLWE(X[\cdot][2j|2j+1])$ -- for $j \in [N/2]$ \label{algline:X}
    \Require $M[j][k]$ -- for $j\in [N]$ and $k\in [T]$ \label{algline:M}
    \Ensure $\RingLWE(Y[\cdot][k])$ -- for $k\in [T]$ \label{algline:Y}
    
    \Statex
    
    \State $Y_0[\cdot][k] = 0$ and $Y_1[\cdot][k] = 0$ \Comment{Initialize two temporary values}\label{algline:init}
    
    \For{$k = 1, \ldots, T$} \label{algline:for_k} 
    	\For{$j = 1, \ldots, N/2$} \label{algline:for_j} 
    		\If{$M[j][k] \neq 0$}
    			\State $\RingLWE(Y_0[\cdot][k]) += M[j][k] \cdot \RingLWE(X[\cdot][2j|2j+1])$ \label{algline:Y_0}
    		\EndIf
    		\If{$M[j+1][k] \neq 0$}
    			\State $\RingLWE(Y_1[\cdot][k]) += M[j+1][k] \cdot \RingLWE(X[\cdot][2j|2j+1])$ \label{algline:Y_0}
    		\EndIf
    	\EndFor
    	\State $\RingLWE(Y[\cdot][k]) = \RingLWE(Y_0[\cdot][k]) + \RingLWE(Y_1[\cdot][k]) \cdot X^{-N/2}$ 
    \EndFor
    
    \State $R = (\vec{0}, 0 + \ldots + 0 \cdot X^{N/2-1} + r_{N/2} \cdot X^{N/2} \ldots + r_{N-1} \cdot X^{N-1})$ \Comment{Random values}
    
    \State $\RingLWE(Y[\cdot][k]) += R$ 
    
\end{algorithmic}\label{alg:computation}
\end{algorithm}



The model is given in cleartext, while the inputs are encrypted with $\RingLWE$. 
The outputs are also encrypted with $\RingLWE$.
We pack into a single $\RingLWE$ ciphertexts 2 columns of the input matrix $X$, scaled with scaling factor $P$.
We multiply this encryption with the plaintext model corresponding to the encrypted columns. 
Before adding them together, we rotate the second one of $N/2$ positions.
Finally, we mask the unused values with random numbers. 

We decrypt $T$ $\RingLWE(Y[\cdot][k])$, each containing the prediction for one tag SNP for all individuals.






\section{Experimental results}

\begin{table}[]
    \centering
    \begin{tabular}{c|c|c|c}
        Application & unary (Not) & binary & ternary (Mux) \\
        \hline
        Simple & 35 & 310 & 64 \\
        Complex & 176 & 401 & 32 
    \end{tabular}
    \caption{Gate count in transaction applications.}
    \label{tab:gate_count}
\end{table}







\bibliographystyle{alpha}
\bibliography{biblio}

\end{document}






